# ----------------------------------------------------------------------------------------------------
# User interaction
# ----------------------------------------------------------------------------------------------------
<<: !include engine_common.yaml

globals:
  # Define the number of consecutive regulations where regulator is at 100% before activating bypass relay
  # When regulator is at 100% and delta is still positive, this counter is incremented
  # When counter reach bypass_timer_threshold, bypass relay is activated
  # Counter is reset to 0 when regulator is not at 100% or when delta is negative
  - id: full_power_timer
    type: int
    restore_value: no
    initial_value: '0'
  # By default, if no temperature package is used, safety_limit is disabled
  - id: safety_limit
    type: bool
    initial_value: "false"

switch:
  # Define is router is active or not
  # When switch is ON, pooling timer will trigger every seconds
  - platform: template
    name: "Activate Solar Routing"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    id: activate
    on_turn_on:
      then:
        - light.turn_on: green_led
        - lambda: id(power_meter_activated) = 1;
    on_turn_off:
      then:
        - light.turn_off: green_led
        - number.to_min: regulator_opening
        - switch.turn_off: energy_divertion
        - lambda: |- 
            id(real_power).publish_state(NAN);
            id(power_meter_activated) = 0;

  # Define the bypass relay
  # When bypass relay is ON, the regulator opening is set to 0
  # When bypass relay is OFF, the regulator opening is set to the value defined by the solar router
  - platform: template
    name: "Bypass Relay"
    id: energy_divertion
    optimistic: true
    on_turn_on:
      then:
        - script.execute: relay_regulation_control
        - number.to_min: regulator_opening
    on_turn_off:
      then:
        - script.execute: relay_regulation_control

number:
  # Report or define regulator opening value
  # If solar routing is not enabled, this value define the level of regulator opening
  # If solar routing is enabled, this value is automatically updated and reflect the level
  #   of regulator opening defined by the solar router
  #   Moving the slider will have an impact on the solar energy diverted and will
  #   immadiatelly be corrected by the solar router. It is advised to not use the slider
  #   when the router is activated.
  - platform: template
    name: "Regulator Opening"
    id: regulator_opening
    min_value: 0
    max_value: 100
    step: 1
    unit_of_measurement: "%"
    optimistic: True
    mode: slider
    on_value:
      then:
        - script.execute: regulation_control
        - if:
            condition:
              number.in_range:
                id: regulator_opening
                above: 1
            then:
              - light.turn_on:
                  id: green_led
                  effect: blink
            else:
              - light.turn_off: green_led
              - if:
                  condition:
                    - switch.is_on: activate
                  then:
                    - light.turn_on: green_led

  # Define the reactivity of regulator opening
  - platform: template
    name: "Reactivity"
    id: reactivity
    optimistic: True
    restore_value: True
    mode: box
    min_value: 1
    max_value: 100
    initial_value: 10
    unit_of_measurement: ""
    step: 1

  # Define the target level of grid exchange
  #   0 : no exchange
  #  <0 : continue the send energy to the grid
  #  >0 : pull energy from the grid to better confort
  - platform: template
    name: "Target grid exchange"
    id: target_grid_exchange
    optimistic: True
    restore_value: True
    mode: box
    min_value: -99999
    max_value: 99999
    initial_value: 0
    unit_of_measurement: "W"
    step: 1

# ----------------------------------------------------------------------------------------------------
# Define scripts for power collection or energy regulation
# ----------------------------------------------------------------------------------------------------

script:
  # Energy Regulation Script
  # -------------------------
  # This script manages energy regulation by adjusting the regulator opening percentage.
  #
  # - It calculates the percentage delta needed to bring the system closer to the target grid exchange.
  # - The closer we are to the target, the smaller the adjustments, to ensure stability.
  # - The `reactivity` parameter scales the delta to avoid oscillations (resonance effects).
  # - If the regulator reaches 100% and the delta remains positive, a bypass relay is activated.
  # - The bypass relay turns on when the regulator is at full power for a duration exceeding 
  #   `bypass_timer_threshold`, preventing unnecessary fluctuations.
  # - If safety conditions are not met (e.g., `safety_limit` is triggered or real power is invalid), 
  #   the system shuts down the regulator and energy diversion.
  - id: energy_regulation
    mode: single
    then:
      - lambda: |-
          // Safety check: Disable regulation if power readings are invalid or safety is triggered
          if (isnan(id(real_power).state) or id(safety_limit)){
            id(regulator_opening).publish_state(0);
            id(energy_divertion).turn_off();
            return;
          }

          // Calculate the power difference and adjust the regulator opening percentage
          double delta = -1*(id(real_power).state-id(target_grid_exchange).state)*id(reactivity).state/1000;
          // Determine the new regulator status
          double regulator_status = id(energy_divertion).state ? 100 : id(regulator_opening).state;
          regulator_status += delta;
          regulator_status = std::max(0.0, std::min(100.0, regulator_status));

          if (regulator_status >= 100) {
            // If at full power, start timing the bypass condition
            if (++id(full_power_timer) >= ${bypass_timer_threshold}) {
              id(energy_divertion).turn_on();
            } else {
              id(regulator_opening).publish_state(regulator_status);
            }
          } else {
            // Reset bypass timer and update regulator state
            id(full_power_timer) = 0;
            id(regulator_opening).publish_state(regulator_status);
            id(energy_divertion).turn_off();
          }
